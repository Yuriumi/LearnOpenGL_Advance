# 高级OpenGL
## 深度测试 [教程链接](https://learnopengl-cn.github.io/04%20Advanced%20OpenGL/01%20Depth%20testing/)

- [ ] 完成**深度测试**学习,并提交Git
- [ ] 完成**模板测试**学习,并提交Git
- [ ] 完成**混合**学习,并提交Git
- [ ] 完成**面剔除**学习,并提交Git
- [ ] 完成**帧缓冲**学习,并提交Git
- [ ] 完成**立方体贴图**学习,并提交Git
- [ ] 完成**高级数据**学习,并提交Git
- [ ] 完成**高级GLSL**学习,并提交Git
- [ ] 完成**几何着色器**学习,并提交Git
- [ ] 完成**实例化**学习,并提交Git
- [ ] 完成**抗锯齿**学习,并提交Git

[TOC]

---

深度缓冲(或z缓冲(z-buffer))中的深度值(Depth Value)与颜色缓冲一样,有着一样的**宽度**和**高度**.  

深度缓冲是由窗口系统自动创建的,以多种float形式存储他的值,大部分系统中,深度缓冲的精度为**24位**.  

深度测试是在片段着色器运行之后(以及模板测试(Stencil Testing)运行之后),在屏幕空间中运行的;可以使用GLSL内建变量*GL_FragCoord*从片段着色器中直接访问;其中的**x**,**y**表示的片段的屏幕空间坐标,而**z分量**包含了片段真正的深度值,深度测试对比的就是**z分量**.  
>特性/提示  
>大部分GPU提供一个叫*提前深度测试*(Early Depth Testing)的硬件特性,允许深度测试在片段着色器之前运行,但前提是我们非常确定这个片段永远是不可见的.  
>片段着色器通常**开销很大**,应尽量避免其运行;当使用提前深度测试时,片段着色器会限制你**不能写入片段的深度值**,片段着色器对深度值进行写入,提前深度测试是不可能的,*OpenGL不能提前知道深度值*.  

深度测试默认是**禁用**的

``` C++
glEnable(GL_DEPTH_TEST);
```

深度测试启用时,片段的深度测试通过,OpenGL会丢弃原本存储的z值;未通过时,会丢弃该片段.启用深度测试,应该在每个渲染迭代前使用*GL_DEPTH_BUFFER_BIT*来清除深度缓冲,否则深度值会一直为上一次渲染迭代的值.

``` C++
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
```

使用深度掩码可以设置深度缓冲的**可读性**,例如我们希望开启深度测试,但不希望深度缓冲更新,让它成为一个**只读**(Read-only).

``` C++
glDepthMask(GL_FALSE);
```

--- 

### 深度测试函数  

OpenGL允许我们修改深度测试中使用的**比较运算符**(也就是让我们自己决定什么条件下更新深度缓冲),调用glDepthFunc函数来修改.

``` C++
glDepthFunc(GL_LESS);
```

| 函数 |描述 |
|--- |--- |
|GL_ALWAYS|永远通过深度测试|
|GL_NEVER|永远不通过深度测试|
|GL_LESS|在片段深度值小于缓冲深度时通过测试|
|GL_EQUAL|在片段深度值等于缓冲深度时通过测试|
|GL_LEQUAL|在片段深度值等于小于缓冲深度时通过测试|
|GL_GEQUAL|在片段深度值大于等于缓冲深度时通过测试|
|GL_GREATER|在片段深度值大于缓冲深度时通过测试|
|GL_NOEQUAL|在片段深度值不等于缓冲深度时通过测试|

默认使用*GL_LESS*,它会丢弃深度值大于等于当前深度值的片段.

### 深度测试的精度

深度缓冲区的缓冲值介于*0.0*和*1.0*之间,其值将会与平截头体内所有的对象的z缓冲进行比较;视图空间中的这些z值可以是平截头体near和far中的任何值;我们需要线性转化他们,使z缓冲位于[0.0,1.0],以下是转化线性方程

> $$F_{depth} = {z - near \over Far - near}$$

![线性方程图像](https://learnopengl-cn.github.io/img/04/01/depth_linear_graph.png)

实践中,线性深度缓冲区*几乎从未使用过*.  

> 特性/提示  
>所有的方程都会将非常近的物体的z缓冲设置为接近0.0的值,而物体非常接近远平面时,他的z缓冲将会非常接近1.0.

为了有正确的投影性质[^1],需要使用一个非线性方程,他与1/z成正比;他能做到的就是在z值很小的时候提供非常高的精度,而在z值很大的时候提供更少的精度.

> $$F_{depth} = {1/z - 1/near\over 1/far - 1-near}$$  

这个非线性方程与1/z成正比,在1.0和2.0之间的z值会变换到1.0到0.5之间的深度值,float为我们提供了一半的精度(z值小精度大),50.0到100.0之间的z值只会占用2%的float精度

只需记住z缓冲的值在屏幕空间中并不是现行的(在**透视矩阵应用之前**在**观察空间之中**是线性的).

![非线性方程图](https://learnopengl-cn.github.io/img/04/01/depth_non_linear_graph.png)

### 深度缓冲可视化

我们可以使用内建gl_FragCoord向量的z值来完成深度缓冲的可视化.

``` C++
void main()
{
    FragColor = vec4(vec3(gl_FragCoord.z),1.0f);
}
```

由于非线性方程的缘故,为了观察到我们希望的黑白渐变图像,应该拉近摄像机,使片元接近进平面.

![渲染深度图](https://learnopengl-cn.github.io/img/04/01/depth_testing_visible_depth.png)

该图很清晰的展示了深度值的非线性特质.

### 深度冲突

两个面非常紧密排列在一起会发生一个常见的视觉错误,z缓冲没有足够的精度来决定那个在前面.结果就是两个面不断地切换先后顺序,这个现象叫做**深度冲突**.

![深度冲突](https://learnopengl-cn.github.io/img/04/01/depth_testing_z_fighting.png)

深度冲突是很常见的问题,尤其是在远处的物体(z值在较大的时候拥有很小的精度).

#### 防止深度冲突

- **永远不要把多个物体摆的太近,以至于他们的一些三角形会重叠**.
- **尽可能将进平面设置的远一些**.
- **牺牲一些性能,使用精度更高的深度缓冲**.
目前有很多抗深度冲突的技术,但都不能完全解决深度冲突.

[^1]: **非正确投影性质**: 1.远处的物体看起来和近处的物体一样大小，**缺乏透视效果**;2.深度精度会随着深度的增加而线性减小，**导致远处的物体出现深度精度问题**；3.由于深度精度的问题，很容易出现*Z-fighting*现象，即两个物体的深度值非常接近，导致交替显示，看起来**闪烁**。